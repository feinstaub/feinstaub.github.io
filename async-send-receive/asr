#!/usr/bin/python

# Copyright (C) 2015 by Gregor Mi <codestruct@posteo.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

#####################################################################
##
## asr - async send receive
## ------------------------
##
## asr is a tool built around the idea to exchange data between
## two computers using a third, completely untrusted, party (like
## internet services, corporate network shares etc.) in an
## asynchronous way.
##
#####################################################################

#
# This file is was edited using kdevelop's Python plugin.
# Praise for kdevelop's plugin:
#   "I just started editing another python script file and remembered that there was the kdevelop-python-plugin.
#   I always thought it comes with kdevelop until I realized it is a separate package.
#   Now that it is installed I can tell you I love it.
#   It makes python editing as fun as it is supposed to be! Great stuff!"
#

#
# Requirements
# - tar
# - openssl
# - python-guidata (has some more python deps)
# - gnome-web-photo (optional)
# - wget (optional)

#
# general:
# http://stackoverflow.com/questions/125951/command-line-program-to-create-website-screenshots-on-linux
#

# gnome-web-photo:
#
# http://xmodulo.com/how-to-take-full-length-screenshot-of-web-page-in-linux.html
# gnome-web-photo -t 20 -m photo http://xmodulo.com/how-to-take-full-length-screenshot-of-web-page-in-linux.html out.png
#
# gnome-web-photo -t 20 -m photo http://192.168.2.200/visu.html?mode=1&flag=16&offset=-1 out2.png
# Timed out while loading 'http://192.168.2.200/visu.html?mode=1&flag=16&offset=-1'. Nothing to output...

# http://cutycapt.sourceforge.net/
# ...

#
# Integration tests:
# -----------------
#
# cd ~/tmp/webphoto
#
## show help:
# ~/dev/src/feinstaub.github.io/async-send-receive/asr -h
#
## send SourceList as configured in given demo-config
# ~/dev/src/feinstaub.github.io/async-send-receive/asr ~/dev/src/feinstaub.github.io/async-send-receive/asr-demo-config --action send
#
## send given source dir
# ~/dev/src/feinstaub.github.io/async-send-receive/asr ~/dev/src/feinstaub.github.io/async-send-receive/asr-demo-config --action send --sourcedir ~/tmp/apidocs
#
## send given some fake source
# ~/dev/src/feinstaub.github.io/async-send-receive/asr ~/dev/src/feinstaub.github.io/async-send-receive/asr-demo-config --action send --unittest use-fake-source
#
## unpack (unencrypt, extract to target dir) given package
# ~/dev/src/feinstaub.github.io/async-send-receive/asr ~/dev/src/feinstaub.github.io/async-send-receive/asr-demo-config --action unpack-only --packagefile demo1-2015-03-27T09_58_16.823101.pak
#

import argparse
import json
from datetime import datetime
import os
#from subprocess import call
import subprocess
import tempfile
import sys
import shutil

# import guidata

#
# globals
#
# use option -h to show help
#
parser = argparse.ArgumentParser(description='asr (async-send-receive) by Gregor Mi (2015)')
parser.add_argument('configfile', help="The config file shared with sender and receiver")
parser.add_argument('--action', help="'send': retrieve source, make package and send | 'receive': retrieve package and unpack | 'unpack-only': unpacks a given package file (see --packagefile)")
parser.add_argument('--sourcedir', help="for --action send: use this directory instead of the configured ones in the configfile (SourceList)")
parser.add_argument('--packagefile', help="filename to a package file; needed for --action unpack")
parser.add_argument('--unittest', help="'use-fake-source': don't process source defined in config file but create a fake file")
args = parser.parse_args()
print("ARGS: configfile: {0}".format(args.configfile))
print("ARGS: action: {0}".format(args.action))
print("ARGS: sourcedir: {0}".format(args.sourcedir))
print("ARGS: packagefile: {0}".format(args.packagefile))
print("ARGS: unittest: {0}".format(args.unittest))

cfgfile = open(args.configfile, 'r')
cfg = json.load(cfgfile)
cfgfile.close()

print("config:--------")
print(cfg)
print("--------")

configId = cfg["Id"]

def dateTimeNowIso():
    """Returns e.g. "2015-03-28T11_36_51-099832"
    """
    now = datetime.today()
    nowStr = now.isoformat().replace(":", "_").replace(".", "-")
    return nowStr

def archiveToFile(sourceDir, targetFilenameBase):
    """compresses the sourceDir to one file
    returns the resulting filename.
    Directory where targetFilenameBase should be created must exist!
    """
    methodCallStr = "archiveToFile: sourceDir:{0}, targetFilenameBase:{1}".format(sourceDir, targetFilenameBase)
    print(methodCallStr)

    # tar -zcvf test.tar.gz 2015-03-25T22_18_46.529128/
    # http://www.cyberciti.biz/faq/how-do-i-compress-a-whole-linux-or-unix-directory/
    # http://stackoverflow.com/questions/939982/how-do-i-tar-a-directory-of-files-and-folders-without-including-the-directory-it
    targetFilename = targetFilenameBase + ".tar.gz"

    #print(os.path.basename(sourceDir))
    #print(os.path.dirname(sourceDir))

    sys.stdout.flush() # flush all python prints so far
    #                            sourceDir="/tmp/hallo/test" =>   /tmp/hallo                  test
    #retCode = call(["tar", "-zcvf", targetFilename, "-C", os.path.dirname(sourceDir), os.path.basename(sourceDir)])
    retCode = subprocess.check_call(["tar", "-zcvf", targetFilename, "-C", sourceDir, "."])
    return targetFilename

def extractArchive(inputFilename, targetDir):
    print("extractArchive")
    sys.stdout.flush() # flush all python prints so far
    subprocess.check_call(["tar", "-zxvf", inputFilename, "-C", targetDir])

def encrypt(sourceFilename, pw, targetFilename):
    """encrypts the file
    """
    print("encrypt")
    # openssl aes-128-cbc -salt -in t1 -out t1.enc -k abcPW
    # http://serverfault.com/questions/489140/what-is-a-good-solution-to-encrypt-some-files-in-unix
    # NOTE: https://www.openssl.org/docs/apps/enc.html
    # - The -salt option should ALWAYS be used if the key is being derived from a password unless you want compatibility with previous versions of OpenSSL and SSLeay.
    #- see there also for cyphers
    sys.stdout.flush() # flush all python prints so far
    subprocess.check_call(["openssl", "aes-128-cbc", "-salt", "-in", sourceFilename, "-out", targetFilename, "-k", pw])

    # not used: gpg
    #http://askubuntu.com/questions/17641/create-encrypted-password-protected-zip-file
    #http://www.cyberciti.biz/tips/linux-how-to-encrypt-and-decrypt-files-with-a-password.html

def decrypt(inputFilename, pw, outputFilename):
    # openssl aes-128-cbc -d -salt -in t1.enc -out t1.dec -k abcPW
    sys.stdout.flush() # flush all python prints so far
    subprocess.check_call(["openssl", "aes-128-cbc", "-d", "-salt", "-in", inputFilename, "-out", outputFilename, "-k", pw])

def doUnpack(inputFilename):
    print("UNPACK")
    uncryptedFile = args.packagefile + ".tar.gz"
    decrypt(args.packagefile, cfg["Package"]["Password"], uncryptedFile)
    print("decrypted: {0}".format(uncryptedFile))

    unpackBaseDir = cfg["Receive"]["UnpackDir"]
    print("unpackBaseDir: {0}".format(unpackBaseDir))

    unpackDir = os.path.join(unpackBaseDir, configId, dateTimeNowIso())
    print("unpackDir: {0}".format(unpackDir))

    if not os.path.exists(unpackDir): # create dir if not exists
        os.makedirs(unpackDir)

    extractArchive(uncryptedFile, unpackDir)
    print("unpacked to: {0}".format(os.path.abspath(unpackDir)))

def processSources():
    """either processes the SourceList defined in the config file
    or takes the --sourcedir argument from command line.

    In the first case the generated temp directory path is returned.
    In the second case the --sourcedir argument is returned as is.
    """
    if (args.sourcedir is not None):
        print("processSources: take --sourcedir which is: {0}. Absolute: {1}".format(args.sourcedir, os.path.abspath(args.sourcedir)))
        return args.sourcedir
    else:
        print("processSources: use SourceList from config file")

        #
        # generate sourcesTargetDir
        #
        sourcesTargetDir = tempfile.mkdtemp()

        #
        # process SourceList or Unit test
        #
        if args.unittest == "use-fake-source":
            print("UNIT TEST because --unittest use-fake-source")
            with open(os.path.join(sourcesTargetDir, "unit-test-file.txt"), "w") as text_file:
                text_file.write("This is a test file")
        else:
            sourceList = cfg["SourceList"]

            for item in sourceList:
                #print(item)
                filename = os.path.join(sourcesTargetDir, item["Filename"]);
                desc = item["Description"];
                uri = item["Uri"];
                tool = item["Tool"];
                print("Name: {0}, Uri: {1}".format(filename, uri))

                if tool == "gnome-web-photo":
                    timeout = item["Timeout"];

                    # gnome-web-photo -t 20 -m photo http://kde.org. out2.png
                    # http://stackoverflow.com/questions/89228/calling-an-external-command-in-python
                    sys.stdout.flush() # flush all python prints so far
                    subprocess.check_call(["gnome-web-photo", "-t", str(timeout), "-m", "photo", uri, filename])
                elif tool == "wget-file":
                    sys.stdout.flush() # flush all python prints so far
                    subprocess.check_call(["wget", uri, "-O", filename])
                elif tool == "wget-web":
                    sys.stdout.flush() # flush all python prints so far
                    subprocess.check_call(["wget", uri])
                else:
                    print("UNKNOWN TOOL: {0}".format(tool))

        return sourcesTargetDir

def sendPackage(pakFilename):
    cfgExchangePointType = cfg["ExchangePointSend"]["Type"]

    if cfgExchangePointType == "filesystem":
        print("cfgExchangePointType == filesystem")
        targetDir = cfg["ExchangePointSend"]["FilesystemConfig"]["Path"]
        absTargetDir = os.path.abspath(targetDir)
        print("targetDir: configured='{0}', absolute='{1}'".format(targetDir, absTargetDir))
        if not os.path.exists(targetDir):
            raise Exception("ERROR: targetDir must exist: {0}".format(absTargetDir))

        shutil.copy(pakFilename, targetDir)

    elif cfgExchangePointType == "ftp":
        print("cfgExchangePointType == ftp")
        print("TODO")
        exit(20)

    else:
        raise Exception("ERROR: cfgExchangePointType unknown: {0}".format(cfgExchangePointType))

def receivePackage():
    print("TODO")

def actionSend():
    #
    # Process sources
    #
    sourceDir = processSources()
    print("sourceDir: {0}".format(os.path.abspath(sourceDir)))

    #
    # make package
    #
    outboxPackagesBaseDir = cfg["Send"]["OutboxDir"]

    if not os.path.exists(outboxPackagesBaseDir): # create dir if not exists
        os.makedirs(outboxPackagesBaseDir)

    # todo: make hash out of configId?
    # https://docs.python.org/2/library/hashlib.html
    packageBaseFilename = os.path.join(outboxPackagesBaseDir, "{0}-{1}".format(configId, dateTimeNowIso()))
    print("packageBaseFilename: {0}".format(os.path.abspath(packageBaseFilename)))

    pakFilename = archiveToFile(sourceDir, packageBaseFilename)
    print("zipped: {0}".format(os.path.abspath(pakFilename)))

    packageFilename = packageBaseFilename + ".pak"
    encrypt(pakFilename, cfg["Package"]["Password"], packageFilename)
    print("package filename: {0}".format(packageFilename))

    #
    # send
    #
    sendPackage(packageFilename)

def actionReceive():
    print("TODO: receive")
    receivePackage() # TODO
    exit(20)

def mainProcess():
    if args.action == "send":
        actionSend()

    elif args.action == "receive":
        actionReceive()

    elif args.action == "unpack-only":
        print("--action unpack-only")
        print("--packagefile: {0}".format(args.packagefile))
        doUnpack(args.packagefile)

    else:
        print("UNKNOWN OR EMPTY --action value")
        # https://pythonhosted.org/guidata/examples.html#basic-example
        # from guidata import tests
        # tests.run()
        exit(1)

#
# run main
#
mainProcess()
