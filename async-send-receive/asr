#!/usr/bin/python

# Copyright (C) 2015 by Gregor Mi <codestruct@posteo.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

#####################################################################
##
## asr - async send receive
## ------------------------
##
## Asr is a tool built around the idea to exchange data between
## two computers using a third, potentially completely untrusted, party
## (like internet hosting services, corporate network shares etc.)
## in an asynchronous way.
##
## Asr currently does not target the ultra-mobile-cloud-user audience
## but more the being-offline kind of use cases. Places in the Internet
## are classified as untrusted sites and private data should lie
## around needlessly or even unprotected.
## So asr tries to provide an electronic way of sending someone a
## package via postal service; including privacy of correspondence,
## posts and telecommunications.
##
## If you send someone a postal package there is usually no trace of the
## package's content between sender and receiver. The only metadata
## which is tracked is who sent it and who received it. Asr also
## tries to minimize public metadata.
##
## As with regular email, the process of sending and receiving is
## asynchronous. The receiver does not have to be online when a package
## is sent.
##
#####################################################################

#
# This file is was edited using kdevelop's Python plugin.
# Praise for kdevelop's plugin:
#   "I just started editing another python script file and remembered that there was the kdevelop-python-plugin.
#   I always thought it comes with kdevelop until I realized it is a separate package.
#   Now that it is installed I can tell you I love it.
#   It makes python editing as fun as it is supposed to be! Great stuff!"
#

#
# Requirements
# - tar
# - openssl
# - python-guidata (has some more python deps)
# - gnome-web-photo (optional)
# - wget (optional)

#
# general:
# http://stackoverflow.com/questions/125951/command-line-program-to-create-website-screenshots-on-linux
#

# gnome-web-photo:
#
# http://xmodulo.com/how-to-take-full-length-screenshot-of-web-page-in-linux.html
# gnome-web-photo -t 20 -m photo http://xmodulo.com/how-to-take-full-length-screenshot-of-web-page-in-linux.html out.png
#
# gnome-web-photo -t 20 -m photo http://192.168.2.200/visu.html?mode=1&flag=16&offset=-1 out2.png
# Timed out while loading 'http://192.168.2.200/visu.html?mode=1&flag=16&offset=-1'. Nothing to output...

# http://cutycapt.sourceforge.net/
# ...

#
# Integration tests:
# -----------------
#
# cd ~/tmp/webphoto
#
## show help:
# ~/dev/src/feinstaub.github.io/async-send-receive/asr -h
#
## send SourceList as configured in given demo-config
# ~/dev/src/feinstaub.github.io/async-send-receive/asr ~/dev/src/feinstaub.github.io/async-send-receive/asr-demo-config --action send
#
## send given source dir
# ~/dev/src/feinstaub.github.io/async-send-receive/asr ~/dev/src/feinstaub.github.io/async-send-receive/asr-demo-config --action send --sourcedir ~/tmp/apidocs
#
## send given some fake source
# ~/dev/src/feinstaub.github.io/async-send-receive/asr ~/dev/src/feinstaub.github.io/async-send-receive/asr-demo-config --action send --unittest use-fake-source
#
## unpack (unencrypt, extract to target dir) given package
# ~/dev/src/feinstaub.github.io/async-send-receive/asr ~/dev/src/feinstaub.github.io/async-send-receive/asr-demo-config --action unpack-only --packagefile demo1-2015-03-27T09_58_16.823101.pak
#

import argparse
import json
from datetime import datetime
import os
#from subprocess import call
import subprocess
import tempfile
import sys
import shutil

# import guidata

#
# globals
#
# use option -h to show help
#
parser = argparse.ArgumentParser(description='asr (async-send-receive) by Gregor Mi (2015)')
parser.add_argument('configfile', help="The config file shared with sender and receiver")
parser.add_argument('--action', help="'send': retrieve source, make package and send | 'receive': retrieve package and unpack | 'unpack-only': unpacks a given package file (see --packagefile)")
parser.add_argument('--sourcedir', help="for --action send: use this directory instead of the configured ones in the configfile (SourceList)")
parser.add_argument('--packagefile', help="filename to a package file; needed for --action unpack")
parser.add_argument('--unittest', help="'use-fake-source': don't process source defined in config file but create a fake file")
args = parser.parse_args()
print("ARGS: configfile: {0}".format(args.configfile))
print("ARGS: action: {0}".format(args.action))
print("ARGS: sourcedir: {0}".format(args.sourcedir))
print("ARGS: packagefile: {0}".format(args.packagefile))
print("ARGS: unittest: {0}".format(args.unittest))

cfgfile = open(args.configfile, 'r')
cfg = json.load(cfgfile)
cfgfile.close()

print("config:--------")
print(cfg)
print("--------")

g_senderId = cfg["SenderId"] # TODO: let this be overridable by command line arguments
g_receiverId = cfg["ReceiverId"] # TODO: let this be overridable by command line arguments
g_outboxDir = os.path.expanduser("~/asr/outbox") # todo: let this be overridable by some config file
g_inboxDir = os.path.expanduser("~/asr/inbox") # todo: let this be overridable by some config file

# TODO use os.path.expanduser(path) when reading config paths

PAK_EXT = ".pak"
DONE_EXT = ".done"
DOWNLOADED_SUBDIR = "1_downloaded"
DECRYPTED_SUBDIR = "2_decrypted"
UNPACKED_SUBDIR = "unpacked"

def dateTimeNowIso():
    """Returns e.g. "2015-03-28T11_36_51-099832"
    """
    now = datetime.today()
    nowStr = now.isoformat().replace(":", "_").replace(".", "-")
    return nowStr

def archiveToFile(sourceDir, targetFilenameBase):
    """compresses the sourceDir to one file
    returns the resulting filename.
    Directory where targetFilenameBase should be created must exist!
    """
    methodCallStr = "archiveToFile: sourceDir:{0}, targetFilenameBase:{1}".format(sourceDir, targetFilenameBase)
    print(methodCallStr)

    # tar -zcvf test.tar.gz 2015-03-25T22_18_46.529128/
    # http://www.cyberciti.biz/faq/how-do-i-compress-a-whole-linux-or-unix-directory/
    # http://stackoverflow.com/questions/939982/how-do-i-tar-a-directory-of-files-and-folders-without-including-the-directory-it
    targetFilename = targetFilenameBase + ".tar.gz"

    #print(os.path.basename(sourceDir))
    #print(os.path.dirname(sourceDir))

    sys.stdout.flush() # flush all python prints so far
    #                            sourceDir="/tmp/hallo/test" =>   /tmp/hallo                  test
    #retCode = call(["tar", "-zcvf", targetFilename, "-C", os.path.dirname(sourceDir), os.path.basename(sourceDir)])
    retCode = subprocess.check_call(["tar", "-zcvf", targetFilename, "-C", sourceDir, "."])
    return targetFilename

def extractArchive(inputFilename, targetDir):
    print("extractArchive")
    sys.stdout.flush() # flush all python prints so far
    subprocess.check_call(["tar", "-zxvf", inputFilename, "-C", targetDir])

def encrypt(sourceFilename, pw, targetFilename):
    """encrypts the file
    """
    print("encrypt")
    # openssl aes-128-cbc -salt -in t1 -out t1.enc -k abcPW
    # http://serverfault.com/questions/489140/what-is-a-good-solution-to-encrypt-some-files-in-unix
    # NOTE: https://www.openssl.org/docs/apps/enc.html
    # - The -salt option should ALWAYS be used if the key is being derived from a password unless you want compatibility with previous versions of OpenSSL and SSLeay.
    #- see there also for cyphers
    sys.stdout.flush() # flush all python prints so far
    subprocess.check_call(["openssl", "aes-128-cbc", "-salt", "-in", sourceFilename, "-out", targetFilename, "-k", pw])

    # not used: gpg
    #http://askubuntu.com/questions/17641/create-encrypted-password-protected-zip-file
    #http://www.cyberciti.biz/tips/linux-how-to-encrypt-and-decrypt-files-with-a-password.html

def decrypt(inputFilename, pw, outputFilename):
    """# openssl aes-128-cbc -d -salt -in t1.enc -out t1.dec -k abcPW
    Creates the intermediate directories of outputFilename if not exist
    """
    sys.stdout.flush() # flush all python prints so far
    p1 = os.path.dirname(outputFilename)
    if not os.path.exists(p1):
        print("decrypt target dir does not exist. CREATE: {0}".format(p1))
        os.makedirs(p1)

    subprocess.check_call(["openssl", "aes-128-cbc", "-d", "-salt", "-in", inputFilename, "-out", outputFilename, "-k", pw])

def unpackPackageToInbox(inputFilename):
    """NOTE that inputFilename can contain an absolute path
    """
    print("unpackPackageToInbox")
    inputBasename = os.path.basename(inputFilename) # final component of pathname
    (packageName, ext) = os.path.splitext(inputBasename)
    if ext != PAK_EXT:
        print("WARN: unpackPackageToInbox: inputFilename should end with PAK_EXT")

    print("packageName: {0}".format(packageName))

    uncryptedFilename = os.path.join(g_inboxDir, DECRYPTED_SUBDIR, packageName + ".tar.gz")
    decrypt(inputFilename, cfg["Package"]["Password"], uncryptedFilename)
    print("decrypted: {0}".format(uncryptedFilename))

    unpackBaseDir = os.path.join(g_inboxDir, UNPACKED_SUBDIR)
    print("unpackBaseDir: {0}".format(unpackBaseDir))

    unpackDir = os.path.join(unpackBaseDir, g_senderId, packageName)
    print("unpackDir: {0}".format(unpackDir))

    if not os.path.exists(unpackDir):
        print("unpackDir does not exist. CREATE: {0}".format(unpackDir))
        os.makedirs(unpackDir)

    extractArchive(uncryptedFilename, unpackDir)
    print("unpacked to: {0}".format(os.path.abspath(unpackDir)))

def processSources():
    """either processes the SourceList defined in the config file
    or takes the --sourcedir argument from command line.

    In the first case the generated temp directory path is returned.
    In the second case the --sourcedir argument is returned as is.
    """
    if (args.sourcedir is not None):
        print("processSources: take --sourcedir which is: {0}. Absolute: {1}".format(args.sourcedir, os.path.abspath(args.sourcedir)))
        return args.sourcedir
    else:
        print("processSources: use SourceList from config file")

        #
        # generate sourcesTargetDir
        #
        sourcesTargetDir = tempfile.mkdtemp()

        #
        # process SourceList or Unit test
        #
        if args.unittest == "use-fake-source":
            print("UNIT TEST because --unittest use-fake-source")
            with open(os.path.join(sourcesTargetDir, "unit-test-file.txt"), "w") as text_file:
                text_file.write("This is a test file")
        else:
            sourceList = cfg["SourceList"]

            for item in sourceList:
                #print(item)
                filename = os.path.join(sourcesTargetDir, item["Filename"]);
                desc = item["Description"];
                uri = item["Uri"];
                tool = item["Tool"];
                print("Name: {0}, Uri: {1}".format(filename, uri))

                if tool == "gnome-web-photo":
                    timeout = item["Timeout"];

                    # gnome-web-photo -t 20 -m photo http://kde.org. out2.png
                    # http://stackoverflow.com/questions/89228/calling-an-external-command-in-python
                    sys.stdout.flush() # flush all python prints so far
                    subprocess.check_call(["gnome-web-photo", "-t", str(timeout), "-m", "photo", uri, filename])
                elif tool == "wget-file":
                    sys.stdout.flush() # flush all python prints so far
                    subprocess.check_call(["wget", uri, "-O", filename])
                elif tool == "wget-web":
                    sys.stdout.flush() # flush all python prints so far
                    subprocess.check_call(["wget", uri])
                else:
                    print("UNKNOWN TOOL: {0}".format(tool))

        return sourcesTargetDir

def sendPackage(pakFilename):
    cfgExchangePointType = cfg["ExchangePointSend"]["Type"]

    if cfgExchangePointType == "filesystem":
        print("cfgExchangePointType == filesystem")
        targetDir = os.path.expanduser(cfg["ExchangePointSend"]["FilesystemConfig"]["Path"])
        absTargetDir = os.path.abspath(targetDir)
        print("targetDir: configured='{0}', absolute='{1}'".format(targetDir, absTargetDir))
        if not os.path.exists(targetDir):
            raise Exception("ERROR: targetDir must exist: {0}".format(absTargetDir))

        shutil.copy(pakFilename, targetDir)

    elif cfgExchangePointType == "ftp":
        print("cfgExchangePointType == ftp")
        print("TODO")
        exit(20)

    else:
        raise Exception("ERROR: cfgExchangePointType unknown: {0}".format(cfgExchangePointType))

def downloadPackages():
    """Copies all packages from the given g_senderId/g_receiverId subfolder
    from the configured exchange point and stores them to the download dir.

    TODO: implement mechanism of deleting the remote files
    """
    cfgExchangePointType = cfg["ExchangePointReceive"]["Type"]

    if cfgExchangePointType == "filesystem":
        print("cfgExchangePointType == filesystem")
        sourceDir = os.path.join(cfg["ExchangePointReceive"]["FilesystemConfig"]["Path"], g_senderId, g_receiverId)
        absSourceDir = os.path.abspath(sourceDir)
        print("sourceDir: configured='{0}', absolute='{1}'".format(sourceDir, absSourceDir))
        if not os.path.exists(sourceDir):
            raise Exception("ERROR: sourceDir must exist: {0}".format(absSourceDir))

        sourceFileList = os.listdir(sourceDir)
        print("SOURCE file list: " + str(sourceFileList))

        downloadBaseDir = os.path.join(g_inboxDir, DOWNLOADED_SUBDIR)
        downloadDir = os.path.join(downloadBaseDir, g_senderId)

        if not os.path.exists(downloadDir):
            print("downloadBaseDir does not exist. CREATE: {0}".format(downloadDir))
            os.makedirs(downloadDir)

        inboxFileList = os.listdir(downloadDir)
        print("INBOX file list: " + str(sourceFileList))

        for filename in sourceFileList:
            packageName = os.path.splitext(filename)[0]
            if packageName + PAK_EXT in inboxFileList:
                print("{0} already downloaded. Skip.".format(filename))
            elif packageName + DONE_EXT in inboxFileList:
                print("{0} already unpacked. Skip.".format(filename))
            else:
                print("{0} not downloaded yet. Download.".format(filename))
                shutil.copy(os.path.join(sourceDir, filename), downloadDir)

    elif cfgExchangePointType == "ftp":
        print("cfgExchangePointType == ftp")
        print("TODO")
        exit(20)

    else:
        raise Exception("ERROR: cfgExchangePointType unknown: {0}".format(cfgExchangePointType))

def unpackDownloadedPackages():
    """Processes all not processed packages (".pak" is not processed, ".done" is processed)
    and unpacks them to the unpack dir.
    """
    downloadBaseDir = os.path.join(g_inboxDir, DOWNLOADED_SUBDIR)
    downloadDir = os.path.join(downloadBaseDir, g_senderId)

    downloadedFilesList = os.listdir(downloadDir)
    for filename in downloadedFilesList:
        (packageName, ext) = os.path.splitext(filename)
        if ext == PAK_EXT:
            unpackPackageToInbox(os.path.join(downloadDir, filename))
        elif ext == DONE_EXT:
            # ignore because already done
            pass
        else:
            print("WARN: unknown filename extension in download dir: {0}".format(ext))

def actionSend():
    #
    # Process sources
    #
    sourceDir = processSources()
    print("sourceDir: {0}".format(os.path.abspath(sourceDir)))

    #
    # make package
    #
    outboxPackagesBaseDir = g_outboxDir

    outboxDir = os.path.join(outboxPackagesBaseDir, g_receiverId)

    if not os.path.exists(outboxDir):
        print("outboxDir does not exist. CREATE: {0}".format(outboxDir))
        os.makedirs(outboxDir)

    # todo: make hash out of senderId?
    # https://docs.python.org/2/library/hashlib.html
    packageBaseFilename = os.path.join(outboxDir, dateTimeNowIso())
    print("packageBaseFilename: {0}".format(os.path.abspath(packageBaseFilename)))

    pakFilename = archiveToFile(sourceDir, packageBaseFilename)
    print("zipped: {0}".format(os.path.abspath(pakFilename)))

    packageFilename = packageBaseFilename + PAK_EXT
    encrypt(pakFilename, cfg["Package"]["Password"], packageFilename)
    print("package filename: {0}".format(packageFilename))

    #
    # send
    #
    sendPackage(packageFilename)

def actionReceive():
    downloadPackages()
    unpackDownloadedPackages()

def mainProcess():
    if args.action == "send":
        actionSend()

    elif args.action == "receive":
        actionReceive()

    elif args.action == "unpack-only":
        print("--action unpack-only")
        print("--packagefile: {0}".format(args.packagefile))
        # g_senderId must be defined (todo: set unknownSender by default)
        unpackPackageToInbox(args.packagefile)

    else:
        print("UNKNOWN OR EMPTY --action value")
        # https://pythonhosted.org/guidata/examples.html#basic-example
        # from guidata import tests
        # tests.run()
        exit(1)

#
# run main
#
mainProcess()
